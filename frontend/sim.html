<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FlowState Simulation</title>


  <style>
    @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;700;800&display=swap');


    :root{
      --bg0:#070b14;
      --bg1:#0b1220;
      --border: rgba(255,255,255,0.14);
      --text:#eaf0ff;
      --muted:#aab5d6;
      --accent:#6ee7ff;
      --accent2:#a78bfa;
    }


    *{ box-sizing:border-box; }


    body{
      margin:0;
      font-family: "Plus Jakarta Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: radial-gradient(1200px 700px at 10% 10%, rgba(110,231,255,0.12), transparent 60%),
                  radial-gradient(900px 600px at 90% 20%, rgba(167,139,250,0.14), transparent 55%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      color:var(--text);
    }


    .topbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      padding: 16px 18px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,0.25);
      backdrop-filter: blur(8px);
    }
    .brand{ color: var(--text); font-weight: 800; text-decoration:none; }
    .status{ color: var(--muted); font-size: 13px; }


    .layout{
      max-width: 1250px;
      margin: 0 auto;
      padding: 16px;
      display:grid;
      grid-template-columns: 390px 1fr;
      gap: 16px;
    }


    .panel{
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      border-radius: 22px;
      padding: 16px;
      box-shadow: 0 14px 40px rgba(0,0,0,0.25);
    }
    .panel h2{ margin: 12px 0 10px; font-size: 15px; }


    .row{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin: 10px 0; }
    .row span{ color: var(--muted); }


    input[type="number"], select{
      width: 160px;
      padding: 9px 10px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.28);
      color: var(--text);
      outline:none;
    }
    input[type="range"]{ width: 170px; }


    .hint{
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 13px;
      line-height:1.4;
    }


    hr{ border:0; border-top:1px solid var(--border); margin: 14px 0; }


    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; }


    button{
      padding: 10px 14px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      cursor:pointer;
      font-weight:700;
      transition: transform .16s ease, background .16s ease, filter .16s ease;
      flex: 1;
      min-width: 160px;
    }
    button:hover{ transform: translateY(-1px); background: rgba(255,255,255,0.11); }


    .primaryBtn{
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      color:#06111f;
      border: 1px solid rgba(255,255,255,0.22);
    }
    .dangerBtn{
      background: rgba(255, 122, 122, 0.14);
      border: 1px solid rgba(255, 122, 122, 0.28);
      width: 100%;
      min-width: unset;
    }


    .canvasWrap{
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      border-radius: 22px;
      padding: 12px;
      box-shadow: 0 14px 40px rgba(0,0,0,0.25);
    }


    .roomFrame{
      border-radius: 18px;
      border: 2px solid rgba(255,255,255,0.22);
      background: rgba(0,0,0,0.18);
      padding: 10px;
      position: relative;
    }
    .roomFrame::after{
      content:"";
      position:absolute;
      inset:10px;
      border-radius: 14px;
      outline: 1px dashed rgba(255,255,255,0.22);
      pointer-events:none;
    }


    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius: 14px;
      background:#ffffff;
      cursor: default;
    }


    .legend{
      margin-top: 10px;
      text-align:center;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }


    .box{
      margin-top: 10px;
      padding: 12px;
      border-radius: 18px;
      background: rgba(0,0,0,0.18);
      border: 1px solid var(--border);
    }
    .hidden{ display:none; }


    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
    }
  </style>
</head>


<body>
  <header class="topbar">
    <a class="brand" href="/">← FlowState</a>
    <div class="status" id="outsideStatus">Outdoor: not checked</div>
  </header>


  <main class="layout">
    <section class="panel">
      <h2>Room Setup</h2>
      <label class="row"><span>Width (px)</span><input id="width" type="number" value="800" /></label>
      <label class="row"><span>Height (px)</span><input id="height" type="number" value="500" /></label>


      <label class="row"><span>Outdoor temp (°C)</span><input id="outTemp" type="number" value="10" /></label>


      <label class="row">
        <span>Heatmap mode</span>
        <select id="mode">
          <option value="co2">CO₂</option>
          <option value="virus">Viruses</option>
          <option value="temp">Heat</option>
        </select>
      </label>


      <button id="createRoomBtn" class="primaryBtn">Create Room</button>


      <div class="hint">
        Drag things on the canvas. Click a window to resize + set openness.  
        Fans: <b>white</b> = manual, <span style="color:#a78bfa"><b>purple ring</b></span> = recommended.
      </div>


      <hr />


      <h2>Outdoor Air</h2>
      <button id="useLocationBtn">Use My Location (pollution)</button>
      <div class="hint">This fetches PM/NO₂/O₃, not outdoor CO₂. Outdoor CO₂ baseline stays ~420 ppm.</div>


      <hr />


      <h2>Objects</h2>
      <div class="btnRow">
        <button id="addFanBtn">Add Fan (manual)</button>
        <button id="addWindowBtn">Add Window</button>
        <button id="addOccBtn">Add Person</button>
      </div>


      <div class="btnRow" style="margin-top:10px">
        <button id="runBtn" class="primaryBtn">Run Simulation</button>
        <button id="recommendBtn">Recommend Fan (AI)</button>
      </div>


      <div class="box">
        <h2 style="margin-top:0">Selected Window</h2>
        <div id="noWindowSelected" class="hint">Click a window to select it.</div>


        <div id="windowTools" class="hidden">
          <label class="row"><span>Window width</span><input id="winWidth" type="range" min="40" max="300" value="120" /></label>
          <label class="row"><span>Open level</span><input id="winOpen" type="range" min="0" max="100" value="100" /></label>
          <button id="deleteWindowBtn" class="dangerBtn">Delete Window</button>
        </div>
      </div>


      <div class="box">
        <h2 style="margin-top:0">Results</h2>
        <div id="results" class="hint">Run simulation to see stats.</div>
      </div>
    </section>


    <section class="canvasWrap">
      <div class="roomFrame">
        <canvas id="roomCanvas" width="800" height="500"></canvas>
      </div>
      <div class="legend">
        Heatmap shows selected mode. Airflow arrows show direction & strength (simple vector field).
      </div>
    </section>
  </main>


  <script>
    // ---------- state ----------
    const canvas = document.getElementById("roomCanvas");
    const ctx = canvas.getContext("2d");


    let room = { width: canvas.width, height: canvas.height };
    let fans = [];      // {id,x,y,type:'manual'|'recommended', strength}
    let windows = [];   // {id,x,y,w,open}
    let occupants = []; // {id,x,y,intensity}


    let selectedWindowId = null;
    let drag = null; // {kind:'fan'|'window'|'occ', id, dx, dy}


    function el(id){ return document.getElementById(id); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function uid(){ return Math.random().toString(16).slice(2); }


    function canvasPoint(evt){
      const r = canvas.getBoundingClientRect();
      return { x: evt.clientX - r.left, y: evt.clientY - r.top };
    }


    // ---------- heatmap coloring ----------
    // CO2: green->yellow->red (absolute bands)
    function heatCO2(v){
      const low=700, mid=1200, high=2000;
      if (v <= low) return "rgb(50,200,120)";
      if (v <= mid){
        const t=(v-low)/(mid-low);
        const r=Math.round(lerp(50,245,t));
        const g=Math.round(lerp(200,230,t));
        const b=Math.round(lerp(120,80,t));
        return `rgb(${r},${g},${b})`;
      }
      if (v <= high){
        const t=(v-mid)/(high-mid);
        const r=245;
        const g=Math.round(lerp(230,90,t));
        const b=80;
        return `rgb(${r},${g},${b})`;
      }
      return "rgb(245,80,80)";
    }


    // Virus: blue->yellow->red (absolute-ish)
    function heatVirus(v){
      const low=1, mid=8, high=25;
      if (v <= low) return "rgb(80,160,255)";
      if (v <= mid){
        const t=(v-low)/(mid-low);
        const r=Math.round(lerp(80,245,t));
        const g=Math.round(lerp(160,230,t));
        const b=Math.round(lerp(255,80,t));
        return `rgb(${r},${g},${b})`;
      }
      if (v <= high){
        const t=(v-mid)/(high-mid);
        const r=245;
        const g=Math.round(lerp(230,90,t));
        const b=80;
        return `rgb(${r},${g},${b})`;
      }
      return "rgb(245,80,80)";
    }


    // Temp: blue(cold)->green->red(hot) around comfort 21
    function heatTemp(t){
      const cold=16, comfy=21, hot=26;
      if (t <= cold) return "rgb(80,160,255)";
      if (t <= comfy){
        const k=(t-cold)/(comfy-cold);
        const r=Math.round(lerp(80,50,k));
        const g=Math.round(lerp(160,200,k));
        const b=Math.round(lerp(255,120,k));
        return `rgb(${r},${g},${b})`;
      }
      if (t <= hot){
        const k=(t-comfy)/(hot-comfy);
        const r=Math.round(lerp(50,245,k));
        const g=Math.round(lerp(200,90,k));
        const b=Math.round(lerp(120,80,k));
        return `rgb(${r},${g},${b})`;
      }
      return "rgb(245,80,80)";
    }


    function drawHeatmap(grid, mode){
      const rows = grid.length;
      const cols = grid[0].length;
      const cellW = canvas.width / cols;
      const cellH = canvas.height / rows;


      for (let y=0;y<rows;y++){
        for (let x=0;x<cols;x++){
          const cell = grid[y][x];
          let c;
          if (mode === "virus") c = heatVirus(cell.virus);
          else if (mode === "temp") c = heatTemp(cell.temp);
          else c = heatCO2(cell.co2);
          ctx.fillStyle = c;
          ctx.fillRect(x*cellW, y*cellH, cellW, cellH);
        }
      }
    }


    function drawVectors(vectors, rows, cols){
      if (!vectors) return;
      const cellW = canvas.width / cols;
      const cellH = canvas.height / rows;


      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(0,0,0,0.7)";
      ctx.lineWidth = 1;


      for (const v of vectors){
        const cx = (v.x + 0.5) * cellW;
        const cy = (v.y + 0.5) * cellH;


        const ux = v.ux;
        const uy = v.uy;
        const mag = Math.sqrt(ux*ux + uy*uy);
        if (mag < 0.05) continue;


        const scale = 10; // arrow length scale
        const ex = cx + ux * scale;
        const ey = cy + uy * scale;


        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(ex, ey);
        ctx.stroke();


        // arrow head
        const ang = Math.atan2(ey-cy, ex-cx);
        const ah = 4;
        ctx.beginPath();
        ctx.moveTo(ex, ey);
        ctx.lineTo(ex - ah*Math.cos(ang-0.6), ey - ah*Math.sin(ang-0.6));
        ctx.lineTo(ex - ah*Math.cos(ang+0.6), ey - ah*Math.sin(ang+0.6));
        ctx.closePath();
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fill();
      }
      ctx.restore();
    }


    function drawOverlay(){
      // windows
      for (const w of windows){
        const isSel = w.id === selectedWindowId;
        ctx.fillStyle = isSel ? "rgba(110,231,255,0.95)" : "rgba(255,255,255,0.75)";
        ctx.fillRect(w.x - w.w/2, w.y - 6, w.w, 12);
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.strokeRect(w.x - w.w/2, w.y - 6, w.w, 12);


        // handles
        ctx.fillStyle = isSel ? "rgba(110,231,255,0.95)" : "rgba(255,255,255,0.85)";
        ctx.fillRect(w.x - w.w/2 - 5, w.y - 10, 10, 20);
        ctx.fillRect(w.x + w.w/2 - 5, w.y - 10, 10, 20);


        // open label
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.font = "700 12px Plus Jakarta Sans, system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillText(`${Math.round(w.open*100)}%`, w.x, w.y - 12);
      }


      // occupants
      for (const p of occupants){
        ctx.beginPath();
        ctx.arc(p.x, p.y, 9, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,200,80,0.95)";
        ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.stroke();


        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.font = "800 12px Plus Jakarta Sans, system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("P", p.x, p.y);
      }


      // fans
      for (const f of fans){
        ctx.beginPath();
        ctx.arc(f.x, f.y, 9, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.stroke();


        if (f.type === "recommended"){
          ctx.beginPath();
          ctx.arc(f.x, f.y, 15, 0, Math.PI*2);
          ctx.strokeStyle = "rgba(167,139,250,0.95)";
          ctx.lineWidth = 3;
          ctx.stroke();
          ctx.lineWidth = 1;


          ctx.fillStyle = "rgba(167,139,250,0.95)";
          ctx.font = "800 14px Plus Jakarta Sans, system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "bottom";
          ctx.fillText("★", f.x, f.y - 18);
        } else {
          ctx.beginPath();
          ctx.arc(f.x, f.y, 14, 0, Math.PI*2);
          ctx.strokeStyle = "rgba(255,255,255,0.35)";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.lineWidth = 1;
        }
      }
    }


    function redrawBlank(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawOverlay();
    }


    // ---------- window tools ----------
    function syncWindowTools(){
      const selected = windows.find(w => w.id === selectedWindowId);
      const tools = el("windowTools");
      const none = el("noWindowSelected");
      if (!selected){
        tools.classList.add("hidden");
        none.classList.remove("hidden");
        return;
      }
      tools.classList.remove("hidden");
      none.classList.add("hidden");
      el("winWidth").value = String(selected.w);
      el("winOpen").value = String(Math.round(selected.open*100));
    }


    function deleteSelectedWindow(){
      if (!selectedWindowId) return;
      windows = windows.filter(w => w.id !== selectedWindowId);
      selectedWindowId = null;
      syncWindowTools();
      redrawBlank();
    }


    // ---------- hit testing ----------
    function hitFan(mx,my){
      for (let i=fans.length-1;i>=0;i--){
        const f=fans[i];
        const dx=mx-f.x, dy=my-f.y;
        if (Math.sqrt(dx*dx+dy*dy) <= 16) return f;
      }
      return null;
    }
    function hitOcc(mx,my){
      for (let i=occupants.length-1;i>=0;i--){
        const p=occupants[i];
        const dx=mx-p.x, dy=my-p.y;
        if (Math.sqrt(dx*dx+dy*dy) <= 16) return p;
      }
      return null;
    }
    function hitWindow(mx,my){
      for (let i=windows.length-1;i>=0;i--){
        const w=windows[i];
        const left=w.x-w.w/2, top=w.y-10;
        if (mx>=left && mx<=left+w.w && my>=top && my<=top+20) return w;
      }
      return null;
    }


    // recommended fan should NOT be draggable
    function canDragFan(f){
      return f && f.type !== "recommended";
    }


    // ---------- dragging ----------
    canvas.addEventListener("mousedown",(e)=>{
      const {x:mx,y:my} = canvasPoint(e);


      const w = hitWindow(mx,my);
      if (w){
        selectedWindowId = w.id;
        syncWindowTools();
        drag = { kind:"window", id:w.id, dx: mx - w.x, dy: my - w.y };
        canvas.style.cursor = "grabbing";
        redrawBlank();
        return;
      }


      const f = hitFan(mx,my);
      if (f && canDragFan(f)){
        drag = { kind:"fan", id:f.id, dx: mx - f.x, dy: my - f.y };
        canvas.style.cursor = "grabbing";
        return;
      }


      const p = hitOcc(mx,my);
      if (p){
        drag = { kind:"occ", id:p.id, dx: mx - p.x, dy: my - p.y };
        canvas.style.cursor = "grabbing";
        return;
      }


      selectedWindowId = null;
      syncWindowTools();
      redrawBlank();
    });


    window.addEventListener("mousemove",(e)=>{
      if (!drag) return;
      const {x:mx,y:my} = canvasPoint(e);


      if (drag.kind==="fan"){
        const f = fans.find(z=>z.id===drag.id);
        if (!f) return;
        f.x = clamp(mx - drag.dx, 0, room.width);
        f.y = clamp(my - drag.dy, 0, room.height);
        redrawBlank();
      }
      if (drag.kind==="occ"){
        const p = occupants.find(z=>z.id===drag.id);
        if (!p) return;
        p.x = clamp(mx - drag.dx, 0, room.width);
        p.y = clamp(my - drag.dy, 0, room.height);
        redrawBlank();
      }
      if (drag.kind==="window"){
        const w = windows.find(z=>z.id===drag.id);
        if (!w) return;
        w.x = clamp(mx - drag.dx, w.w/2, room.width - w.w/2);
        w.y = clamp(my - drag.dy, 20, room.height - 20);
        redrawBlank();
      }
    });


    window.addEventListener("mouseup",()=>{
      drag = null;
      canvas.style.cursor = "default";
    });


    // resize + openness
    el("winWidth").addEventListener("input", ()=>{
      const w = windows.find(z=>z.id===selectedWindowId);
      if (!w) return;
      w.w = Number(el("winWidth").value);
      w.x = clamp(w.x, w.w/2, room.width - w.w/2);
      redrawBlank();
    });
    el("winOpen").addEventListener("input", ()=>{
      const w = windows.find(z=>z.id===selectedWindowId);
      if (!w) return;
      w.open = clamp(Number(el("winOpen").value)/100, 0, 1);
      redrawBlank();
    });


    // ---------- API ----------
    async function postJSON(url, body){
      const res = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body)
      });
      const data = await res.json().catch(()=>({}));
      if (!res.ok) throw new Error(data.error || `Request failed: ${res.status}`);
      return data;
    }


    function payload(){
      const outTemp = Number(el("outTemp").value);
      return {
        width: room.width,
        height: room.height,
        fans: fans.map(f=>({ x:f.x, y:f.y, strength: f.strength ?? 1 })),
        windows: windows.map(w=>({ x:w.x, y:w.y, w:w.w, open:w.open })),
        occupants: occupants.map(p=>({ x:p.x, y:p.y, intensity: p.intensity ?? 1 })),
        outdoor: { co2: 420, temp: Number.isFinite(outTemp) ? outTemp : 10 }
      };
    }


    async function runSimulation(){
      const mode = el("mode").value;
      const result = await postJSON("/simulate", payload());


      drawHeatmap(result.grid, mode);
      drawVectors(result.vectors, result.meta.rows, result.meta.cols);
      drawOverlay();


      const s = result.stats;
      el("results").innerHTML =
        `Avg CO₂: <b>${Math.round(s.avgCO2)}</b> ppm • Max CO₂: <b>${Math.round(s.maxCO2)}</b> ppm<br/>` +
        `Avg Virus: <b>${(s.avgVirus).toFixed(2)}</b> • Max Virus: <b>${(s.maxVirus).toFixed(2)}</b><br/>` +
        `Avg Temp: <b>${(s.avgTemp).toFixed(1)}</b> °C`;
    }


    async function recommendFan(){
      const data = await postJSON("/optimize", payload());


      // remove existing recommended
      fans = fans.filter(f=>f.type!=="recommended");


      if (data.bestFan){
        fans.push({ id: uid(), x: data.bestFan.x, y: data.bestFan.y, type:"recommended", strength: 1 });
      }


      await runSimulation();
      alert(`Recommended fan placement set (purple ring).\nScore: ${data.score}`);
    }


    async function useMyLocation(){
      if (!navigator.geolocation) throw new Error("Geolocation not supported.");
      el("outsideStatus").textContent = "Outdoor: checking…";


      const pos = await new Promise((resolve,reject)=>{
        navigator.geolocation.getCurrentPosition(resolve, reject, { enableHighAccuracy:true, timeout:10000 });
      });


      const { latitude, longitude } = pos.coords;
      const res = await fetch(`/airquality?lat=${encodeURIComponent(latitude)}&lon=${encodeURIComponent(longitude)}`);
      const aq = await res.json().catch(()=>({}));
      if (!res.ok) throw new Error(aq.error || "Outdoor check failed");


      const parts = [];
      if (aq.pm25 != null) parts.push(`PM2.5 ${aq.pm25}`);
      if (aq.pm10 != null) parts.push(`PM10 ${aq.pm10}`);
      if (aq.no2 != null) parts.push(`NO₂ ${aq.no2}`);
      if (aq.o3 != null) parts.push(`O₃ ${aq.o3}`);


      el("outsideStatus").textContent = `Outdoor (${aq.source}): ${parts.join(" • ") || "ok"} (not CO₂)`;
    }


    // ---------- buttons ----------
    function createRoom(){
      const w = Number(el("width").value || 800);
      const h = Number(el("height").value || 500);


      room.width = clamp(w, 250, 2200);
      room.height = clamp(h, 250, 1400);


      canvas.width = room.width;
      canvas.height = room.height;


      fans = [];
      windows = [];
      occupants = [];
      selectedWindowId = null;
      syncWindowTools();


      el("results").textContent = "Room created. Add objects, then run simulation.";
      redrawBlank();
    }


    function addFan(){
      fans.push({ id: uid(), x: room.width*0.5, y: room.height*0.5, type:"manual", strength: 1 });
      redrawBlank();
    }


    function addWindow(){
      const id = uid();
      windows.push({ id, x: room.width*0.25, y: room.height*0.18, w: 140, open: 1 });
      selectedWindowId = id;
      syncWindowTools();
      redrawBlank();
    }


    function addOcc(){
      occupants.push({ id: uid(), x: room.width*0.65, y: room.height*0.55, intensity: 1 });
      redrawBlank();
    }


    el("createRoomBtn").addEventListener("click", createRoom);
    el("useLocationBtn").addEventListener("click", ()=> useMyLocation().catch(e=>{
      el("outsideStatus").textContent = `Outdoor: ${e.message}`;
    }));
    el("addFanBtn").addEventListener("click", addFan);
    el("addWindowBtn").addEventListener("click", addWindow);
    el("addOccBtn").addEventListener("click", addOcc);
    el("runBtn").addEventListener("click", ()=> runSimulation().catch(e=> alert(e.message)));
    el("recommendBtn").addEventListener("click", ()=> recommendFan().catch(e=> alert(e.message)));
    el("deleteWindowBtn").addEventListener("click", deleteSelectedWindow);


    // init
    syncWindowTools();
    redrawBlank();
  </script>
</body>
</html>
